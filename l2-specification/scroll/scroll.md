# Scroll

## Glossary

- **Batch**: A group of zero or more L2 blocks batched together in sequential order by block number.
- **Block**: Generated by the Sequencer and contains zero or more executed L2 transactions.
- **Committed Blocks**: An L2 block where the transaction data is only posted on the Rollup Contract. The block data is available, but the data has not been proven.
- **Coordinator**: Randomly selects Rollers for block proof generation and aggregation proof generation. Finalizes L2 blocks by sending the aggregation proof to the Rollup Contract via the Relayer. 
- **Finalized Blocks**: An L2 block where the transaction data is posted on the Rollup Contract and the data is proven by verifying a validity proof.
- **Relayer**: Monitors the Rollup Contract to keep track of the data availability and validity proofs for L2 blocks. Also, monitors the deposit and withdraw events from the bridge contracts deployed on both Ethereum and Scroll.
- **Roller**: Generates the zkEVM validity proofs to prove that transactions are executed correctly.
- **Roller Pool**: A group of Rollers that the Coordinator can select from when delegating proof generation.
- **Rollup Contract**: Smart contract deployed on Ethereum. Receives sequenced batches from the Sequencer and validity proofs from the Coordinator.
- **Sequencer**: Geth fork. Provides a JSON-RPC interface and accepts L2 transactions. Generates blocks by grouping transactions from the pending transaction pool and executing them. Creates batches of blocks, sequences batches, and submits the sequenced batches to the Rollup Contract.
- **Uncommitted Blocks**: An L2 block that has been proposed by a Sequencer and sent to a Roller for block proof generation. The block's transaction data is not yet posted to the Rollup Contract and the data is not proven.

## Transaction Lifecycle

1. A user submits a transaction to the Sequencer.
2. The transaction is placed in the Pending Transaction Pool.
3. Every ~3 seconds, the Sequencer retrieves a group of transactions from the Pending Transaction Pool.
4. Sequencer executes the group of transactions to generate a new L2 block and state root.
5. Coordinator is notified of the new L2 block and receives the block execution trace from the Sequencer.
6. Coordinator dispatches the block's execution trace to a randomly-selected Roller from the roller pool.
7. The selected Roller generates a validity proof for the block trace.
   - Note: Proofs for different blocks can be generated in parallel by different Rollers.
8. Roller sends the block proof back to the Coordinator.
9. Sequencer rolls up uncommitted blocks into a batch.
10. Sequencer collects batches and creates a sequence.
11. Sequencer sends the transaction data and state roots for the sequenced batches to the Relayer.
12. Relayer submits the batch data to the Rollup Contract.
13. Relayer broadcasts the committed batch data to the Coordinator.
14. Coordinator dispatches an aggregation task to a randomly-selected Roller.
15. The selected Roller aggregates the block proofs into a single aggregate proof.
16. Roller sends the aggregate proof back to the Coordinator.
17. Coordinator sends the aggregate proof to the Relayer.
18. Relayer submits the aggregate proof to the Rollup contract.
19. Rollup Contract verifies the aggregate proof against the state roots and transaction data previously submitted to the rollup contract to finalize the L2 blocks.

## Sequence Diagram

![Scroll Sequence Diagram](https://github.com/quantstamp/efg-block-explorer-api/assets/118835395/9492ad74-6076-44a5-a665-c49e4e1a68f0)

## Entity Relationship Diagram

![Scroll Entity Relationship](https://github.com/quantstamp/efg-block-explorer-api/assets/118835395/632c08be-25c3-4f29-9468-cfa4bb147b48)

## Sequenced Batches

![Scroll Batches Diagram](https://github.com/quantstamp/efg-block-explorer-api/assets/118835395/81a15f11-9844-49fd-9b0f-0aa783196d04)
